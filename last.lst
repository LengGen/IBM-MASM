Microsoft (R) Macro Assembler Version 6.11		    10/28/20 11:12:58
tempfile.asm						     Page 1 - 1


				;默认采用ML6.11汇编程序
 0000				DATAS SEGMENT
				    ;此处输入数据段代码 
 0000  0014 [			    ARRAYM DB 20 DUP (?)		;总数组
        00
       ]
 0014  0014 [			    ARRAYPLUS DB 20 DUP (?)		;正数数组
        00
       ]
 0028  0014 [			    ARRAYMINUS DB 20 DUP (?)	;负数数组
        00
       ]
 003C 51 00			    BUF DB 81, 0, 81 DUP(0)    	;缓冲区
       0051 [
        00
       ]
				    
 008F 50 6C 65 61 73 65		    inputting DB 'Please input a double-digit:$'
       20 69 6E 70 75 74
       20 61 20 64 6F 75
       62 6C 65 2D 64 69
       67 69 74 3A 24
 00AC 0D 0A 54 68 65 20		    outputcount DB 0DH,0AH,'The number of minus numbers is:$'
       6E 75 6D 62 65 72
       20 6F 66 20 6D 69
       6E 75 73 20 6E 75
       6D 62 65 72 73 20
       69 73 3A 24
 00CE 0D 0A 54 68 65 20		    outputsum DB 0DH,0AH,'The sum of plus numbers is:$'
       73 75 6D 20 6F 66
       20 70 6C 75 73 20
       6E 75 6D 62 65 72
       73 20 69 73 3A 24
				    
 00EC 0D 0A 24			    GOLINE DB 0DH,0AH,'$'
 00EF 00			    PLUSCOUNT DB 0            	;正数个数
 00F0 00			    MINUSCOUNT DB 0			  	;负数个数
 00F1				DATAS ENDS

 0000				STACKS SEGMENT
				    ;此处输入堆栈段代码
 0000  0064 [			    DB 100 DUP (0)
        00
       ]
 0064				STACKS ENDS

 0000				CODES SEGMENT
				    ASSUME CS:CODES,DS:DATAS,SS:STACKS
 0000				START:
 0000  B8 ---- R		    MOV AX,DATAS
 0003  8E D8			    MOV DS,AX
				    ;此处输入代码段代码
				    
 0005  8D 1E 0000 R		    LEA BX,ARRAYM
 0009  B1 14			    MOV CL,20         	;计数
 000B  B5 00			    MOV CH,0
				    
 000D  8D 16 008F R		L1: LEA DX,inputting
 0011  B4 09			    MOV AH,9
 0013  CD 21			    INT 21H
				    
 0015  8D 16 003C R		    LEA DX,BUF       	;输入数据到缓冲区
 0019  B4 0A			    MOV AH,10
 001B  CD 21			    INT 21H
				    
 001D  8D 16 00EC R		    LEA DX,GOLINE      ;换行
 0021  B4 09			    MOV AH,9
 0023  CD 21			    INT 21H
				    
 0025  8D 36 003C R		    LEA SI,BUF
 0029  8A 44 02			    MOV AL,[SI+2]    	;可能是十位或 " - "
 002C  3C 2D			    CMP AL,'-'
 002E  74 1D			    JE FUHAO
				    
 0030  2C 30			    SUB AL,30H			;将字符类型转成数字类型
 0032  B6 03			    MOV DH,3
 0034  86 F1			    XCHG DH,CL
				    ;下面进行 AL*10 -> AL
 0036  8A D0			    MOV DL,AL
 0038  D2 E0			    SHL AL,CL			;左移三位，乘8
 003A  02 C2			    ADD AL,DL
 003C  02 C2			    ADD AL,DL
				 
 003E  02 44 03			    ADD AL,[SI+3]		;再加上个位
 0041  2C 30			    SUB AL,30H
 0043  88 07			    MOV [BX],AL    	;将二位数存入ARRAYM中
				    
 0045  FE 06 00EF R		    INC PLUSCOUNT
 0049  86 F1			    XCHG DH,CL
 004B  EB 23			    JMP L2
				    
 004D				FUHAO: 
 004D  8A 44 03				MOV AL,[SI+3]   	;获取十位
					
 0050  2C 30				SUB AL,30H			;将字符类型转成数字类型
 0052  B6 03			    MOV DH,3
 0054  86 F1			    XCHG DH,CL
				    
 0056  8A D0				MOV DL,AL
 0058  D2 E0				SHL AL,CL
 005A  02 C2				ADD AL,DL
 005C  02 C2				ADD AL,DL
					
 005E  8A 54 04				MOV DL,[SI+4]
 0061  80 EA 30				SUB DL,30H
					
 0064  02 C2				ADD AL,DL
					
 0066  F6 D8				NEG AL				;求得相反数存入
					
 0068  88 07				MOV [BX],AL     	;存入ARRAYM中
 006A  FE 06 00F0 R			INC MINUSCOUNT
					
 006E  86 F1				XCHG DH,CL
 0070				L2:  
 0070  83 C3 01				ADD BX,1
 0073  E2 98				LOOP L1 	     
					
 0075  8D 36 0000 R			LEA SI,ARRAYM
 0079  8D 3E 0014 R			LEA DI,ARRAYPLUS
 007D  8D 1E 0028 R			LEA BX,ARRAYMINUS
					
 0081  8C D8				MOV AX,DS
 0083  8E C0				MOV ES,AX
					;所有数据都在一个段中  所以设置 ES=DS  串处理指令中DI和ES联用
					
 0085  B1 14				MOV CL,20		;循环的次数
 0087  B5 00				MOV CH,0
 0089  FC				CLD 			;让DF=0,从前往后读取
					
 008A				DIVIDE:
 008A  AC				LODSB			;从ARRAYM中取出一个字节的数据到AL中  并且SI指针+1
					
 008B  A8 80				TEST AL,80H		;检测符号位，判断是正数还是负数  两个操作数相与，根据结果是否为0来设置ZF
									;如果相与的结果为0，则ZF=1，说明符号位为0，是正数 ；如果结果不为0，则ZF=0，说明符号位是1，是负数
					
 008D  75 03				JNZ MINUS		;如果ZF=0，是负数，则转向minus。  判断ZF，如果ZF=1，是正数，则不跳转。 
 008F  AA				STOSB			;ZF=1,是正数，将AL中的数据存到（（DI））中去  并且DI指针+1
					
 0090  EB 05				JMP AGAIN		;执行完操作后，跳转到agiin，准备下一次循环

 0092				MINUS:
 0092  87 DF				XCHG BX,DI		;交换BX,DI  将目的地址转成负数组的地址，然后开始对负数组内容进行操作
 0094  AA				STOSB			;把AL中的数据存入到((DI))中去，也就是把负数存入ARRAYMINUS数组中去,并且DI指针+1
					
 0095  87 DF				XCHG BX,DI		;操作完毕后，将BX,DI交换回来，准备进行下一个字节的循环操作。
					
 0097				AGAIN:
 0097  49				DEC CX			;计数-1，也就是循环次数减少一次。 这个指令会影响ZF的值
 0098  75 F0				JNZ DIVIDE		;完成正负数据分离  只有ZF=0，也就是CX的值不为0的时候 才会跳转。
					
					;打印负数个数
 009A  8D 16 00AC R			LEA DX,outputcount
 009E  B4 09				MOV AH,9
 00A0  CD 21			    INT 21H
					
 00A2  A0 00F0 R			MOV AL,MINUSCOUNT
 00A5  98				CBW
 00A6  B3 0A				MOV BL,10
 00A8  F6 F3				DIV BL			;AX/BL 余数存在AH中，商在AL中
 00AA  8B D0				MOV DX,AX
 00AC  81 C2 3030			ADD DX,3030H
 00B0  B4 02				MOV AH,2
 00B2  CD 21				INT 21H
					
 00B4  8A D6				MOV DL,DH
 00B6  B4 02				MOV AH,2
 00B8  CD 21				INT 21H
					
 00BA  8D 16 00CE R			LEA DX,outputsum
 00BE  B4 09				MOV AH,9
 00C0  CD 21			    INT 21H
					
					;开始做累加操作
 00C2  8D 36 0014 R			LEA SI,ARRAYPLUS
 00C6  8A 0E 00EF R			MOV CL,PLUSCOUNT
 00CA  B5 00				MOV CH,0
 00CC  BB 0000				MOV BX,0  		;将累加的和放到BX中
 00CF  FC				CLD
 00D0				ACCUMULATE:
 00D0  AC				LODSB			;从ARRAYPLUS中取出一个字节的数据到AL中  并且SI指针+1
 00D1  98				CBW 			;将AL -> AX 转换为字，表示的数的大小不变
 00D2  03 D8				ADD BX,AX		;累加
 00D4  B8 0000				MOV AX,0		;将AX置位0，以免影响后续操作
					
 00D7  49				DEC CX
 00D8  75 F6				JNZ ACCUMULATE
					
					;输出累加和
 00DA  8B C3				MOV AX,BX
 00DC  B3 0A				MOV BL,10
 00DE  F6 F3				DIV BL			;AX/BL  余数在AH 商在AL
 00E0  8A FC				MOV BH,AH		;先把余数保存起来, 对商进行进一步的操作

 00E2  98				CBW				;AL -> AX
 00E3  F6 F3				DIV BL			;AX/BL  余数在AH，商在AL
 00E5  8B D0				MOV DX,AX
 00E7  81 C2 3030			ADD DX,3030H
 00EB  B4 02				MOV AH,2		;输出百位
 00ED  CD 21				INT 21H
					
 00EF  8A D6				MOV DL,DH
 00F1  B4 02				MOV AH,2		;输出十位
 00F3  CD 21				INT 21H
					
 00F5  8A D7				MOV DL,BH
 00F7  80 C2 30				ADD DL,30H
 00FA  B4 02				MOV AH,2		;输出个位
 00FC  CD 21				INT 21H
					
 00FE  8D 16 00EC R			LEA DX,GOLINE
 0102  B4 09				MOV AH,9
 0104  CD 21				INT 21H
					
 0106  B4 4C			    MOV AH,4CH
 0108  CD 21			    INT 21H
 010A				CODES ENDS
				    END START
Microsoft (R) Macro Assembler Version 6.11		    10/28/20 11:12:58
tempfile.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CODES  . . . . . . . . . . . . .	16 Bit	 010A	  Para	  Private 
DATAS  . . . . . . . . . . . . .	16 Bit	 00F1	  Para	  Private 
STACKS . . . . . . . . . . . . .	16 Bit	 0064	  Para	  Private 


Symbols:

                N a m e                 Type     Value    Attr

ACCUMULATE . . . . . . . . . . .	L Near	 00D0	  CODES	
AGAIN  . . . . . . . . . . . . .	L Near	 0097	  CODES	
ARRAYMINUS . . . . . . . . . . .	Byte	 0028	  DATAS	
ARRAYM . . . . . . . . . . . . .	Byte	 0000	  DATAS	
ARRAYPLUS  . . . . . . . . . . .	Byte	 0014	  DATAS	
BUF  . . . . . . . . . . . . . .	Byte	 003C	  DATAS	
DIVIDE . . . . . . . . . . . . .	L Near	 008A	  CODES	
FUHAO  . . . . . . . . . . . . .	L Near	 004D	  CODES	
GOLINE . . . . . . . . . . . . .	Byte	 00EC	  DATAS	
L1 . . . . . . . . . . . . . . .	L Near	 000D	  CODES	
L2 . . . . . . . . . . . . . . .	L Near	 0070	  CODES	
MINUSCOUNT . . . . . . . . . . .	Byte	 00F0	  DATAS	
MINUS  . . . . . . . . . . . . .	L Near	 0092	  CODES	
PLUSCOUNT  . . . . . . . . . . .	Byte	 00EF	  DATAS	
START  . . . . . . . . . . . . .	L Near	 0000	  CODES	
inputting  . . . . . . . . . . .	Byte	 008F	  DATAS	
outputcount  . . . . . . . . . .	Byte	 00AC	  DATAS	
outputsum  . . . . . . . . . . .	Byte	 00CE	  DATAS	

	   0 Warnings
	   0 Errors
